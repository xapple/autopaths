<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>autopaths.base_path API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>autopaths.base_path</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
&#34;&#34;&#34;

# Built-in modules #
import os, glob

# Internal modules #
import autopaths

# Constants #
if os.name == &#34;posix&#34;: sep = &#34;/&#34;
if os.name == &#34;nt&#34;:    sep = &#34;\\&#34;

################################################################################
class BasePath(str):
    &#34;&#34;&#34;
    This object contains methods that are common to both FilePath objects
    and DirectoryPath objects.
    &#34;&#34;&#34;

    def __repr__(self):
        return &#39;&lt;%s object &#34;%s&#34;&gt;&#39; % (self.__class__.__name__, self.path)

    @classmethod
    def clean_path(cls, path):
        &#34;&#34;&#34;Given a path, return a cleaned up version for initialization.&#34;&#34;&#34;
        # Conserve &#39;None&#39; object style #
        if path is None: return None
        # Don&#39;t nest BasePaths object or the like #
        if hasattr(path, &#39;path&#39;): path = path.path
        # Expand the tilda #
        if &#34;~&#34; in path: path = os.path.expanduser(path)
        # We will store the path with the OS specific separator #
        # We will never mix both kinds of separators #
        if os.name == &#34;posix&#34;: path = path.replace(&#34;\\&#34;, sep)
        if os.name == &#34;nt&#34;:    path = path.replace(&#34;/&#34;,  sep)
        # Expand star #
        if &#34;*&#34; in path:
            matches = glob.glob(path)
            if len(matches) &lt; 1:
                raise Exception(&#34;Found exactly no paths matching &#39;%s&#39;&#34; % path)
            if len(matches) &gt; 1:
                raise Exception(&#34;Found several paths matching &#39;%s&#39;&#34; % path)
            path = matches[0]
        # Our standard is to end with a slash for directories #
        if cls is autopaths.dir_path.DirectoryPath:
            if not path.endswith(sep):
                path += sep
        # Return the result #
        return path

    def __new__(cls, path, *args, **kwargs):
        &#34;&#34;&#34;A Path object is in fact a string.&#34;&#34;&#34;
        return str.__new__(cls, cls.clean_path(path))

    def __init__(self, path):
        self.path = self.clean_path(path)

    def __add__(self, other):
        if os.name == &#34;posix&#34;: other = other.replace(&#34;\\&#34;, sep)
        if os.name == &#34;nt&#34;:    other = other.replace(&#34;/&#34;,  sep)
        if other.endswith(sep):
            return autopaths.dir_path.DirectoryPath(self.path + other)
        else:
            return autopaths.file_path.FilePath(self.path + other)

    #------------------------------- Properties ------------------------------#
    @property
    def short_prefix(self):
        &#34;&#34;&#34;Just the filename without any extension or periods.&#34;&#34;&#34;
        return self.name.split(&#39;.&#39;)[0]

    @property
    def extension(self):
        &#34;&#34;&#34;The extension with the leading period.&#34;&#34;&#34;
        return os.path.splitext(self.path)[1]

    @property
    def escaped(self):
        &#34;&#34;&#34;
        The path with special characters escaped.
        For instance a backslash becomes a double backslash.
        &#34;&#34;&#34;
        return self.path.replace(&#34;\\&#34;, &#34;\\\\&#34;)

    @property
    def absolute_path(self):
        &#34;&#34;&#34;The absolute path starting with a `/`.&#34;&#34;&#34;
        return self.__class__(os.path.abspath(self.path))

    @property
    def physical_path(self):
        &#34;&#34;&#34;The physical path like in `pwd -P`.&#34;&#34;&#34;
        return self.__class__(os.path.realpath(self.path))

    @property
    def with_tilda(self):
        &#34;&#34;&#34;
        The absolute path starting with a &#39;~&#39; if it&#39;s in the home.
        Returns a string, not an autopaths object, since autopaths can&#39;t
        be encoded with a tilda.
        &#34;&#34;&#34;
        # Get variables #
        home = os.path.expanduser(&#39;~&#39;)
        path = self.absolute_path
        # Check we are in the home #
        if not path.startswith(home): return path
        # Replace #
        return path.replace(home, &#39;~&#39;, 1)

    @property
    def relative_path(self):
        &#34;&#34;&#34;The relative path when compared with current directory.&#34;&#34;&#34;
        return self.__class__(os.path.relpath(self.physical_path))

    def rel_path_from(self, path):
        &#34;&#34;&#34;The relative path when compared to the given path.&#34;&#34;&#34;
        return self.__class__(os.path.relpath(self.path, path))

    @property
    def unix_style(self):
        &#34;&#34;&#34;The path with forward slashes and no disk drive.&#34;&#34;&#34;
        if self.path[1] == &#39;:&#39;: path = self.path[2:]
        else:                   path = self.path
        return path.replace(&#34;\\&#34;, &#34;/&#34;)

    @property
    def wsl_style(self):
        &#34;&#34;&#34;
        The path with forward slashes and a windows subsystem
        for linux style leading disk drive.
        &#34;&#34;&#34;
        return &#34;/mnt/c&#34; + self.unix_style

    @property
    def win_style(self):
        &#34;&#34;&#34;The path with backward slashes.&#34;&#34;&#34;
        return self.path.replace(&#34;/&#34;, &#34;\\&#34;)

    @property
    def exists(self):
        &#34;&#34;&#34;
        Does it exist in the file system?
        Returns True even for broken symbolic links.
        &#34;&#34;&#34;
        return os.path.lexists(self.path)

    @property
    def is_symlink(self):
        &#34;&#34;&#34;Is this file a symbolic link to an other file?&#34;&#34;&#34;
        if os.name == &#34;posix&#34;: return os.path.islink(self.path)
        if os.name == &#34;nt&#34;:
            import win32api
            import win32con
            num = win32con.FILE_ATTRIBUTE_REPARSE_POINT
            return bool(win32api.GetFileAttributes(self.path) &amp; num)

    @property
    def permissions(self):
        &#34;&#34;&#34;Convenience object for dealing with permissions.&#34;&#34;&#34;
        return autopaths.file_permissions.FilePermissions(self.path)

    @property
    def mdate(self):
        &#34;&#34;&#34;Return the modification date as a unix time.&#34;&#34;&#34;
        return os.path.getmtime(self.path)

    @property
    def mdate_iso(self):
        &#34;&#34;&#34;Return the modification date as a datetime iso object.&#34;&#34;&#34;
        import datetime
        return datetime.fromtimestamp(self.mdate).isoformat()

    @property
    def cdate(self):
        &#34;&#34;&#34;Return the creation date.&#34;&#34;&#34;
        return os.path.getctime(self.path)

    @property
    def cdate_iso(self):
        &#34;&#34;&#34;Return the creation date as a datetime iso object.&#34;&#34;&#34;
        import datetime
        return datetime.fromtimestamp(self.cdate).isoformat()

    #------------------------------ Soft links -------------------------------#
    def link_from(self, path, safe=False, absolute=False):
        &#34;&#34;&#34;
        Make a link here pointing to another file/directory somewhere else.
        The destination is hence *self* and the source is *path*.
        &#34;&#34;&#34;
        # Get source and destination #
        from autopaths import Path
        source      = Path(path)
        destination = self
        # Call method #
        self._symlink(source, destination, safe, absolute)

    def link_to(self, path, safe=False, absolute=False):
        &#34;&#34;&#34;
        Create a link somewhere else pointing to this file.
        The destination is hence *path* and the source is *self*.
        &#34;&#34;&#34;
        # Get source and destination #
        from autopaths import Path
        source      = self
        destination = Path(path)
        # Call method #
        self._symlink(source, destination, safe, absolute)

    def _symlink(self, source, destination, safe, absolute):
        # If source is a file and the destination is a dir, put it inside #
        if os.path.isdir(destination) and not os.path.isdir(source):
            destination = destination + source.filename
        # Do we want absolute paths #
        if absolute: source = source.absolute_path
        # Strip trailing separators #
        source      = source.rstrip(sep)
        destination = destination.rstrip(sep)
        # Windows doesn&#39;t have os.symlink #
        if os.name == &#34;posix&#34;:
            self.symlinks_on_linux(source, destination, safe)
        if os.name == &#34;nt&#34;:
            self.symlinks_on_windows(source, destination, safe)

    @staticmethod
    def symlinks_on_linux(source, destination, safe):
        # Do it unsafely #
        if not safe:
            if os.path.exists(destination) or os.path.islink(destination):
                os.remove(destination)
            os.symlink(source, destination)
        # Do it safely #
        if safe:
            try: os.remove(destination)
            except OSError: pass
            try: os.symlink(source, destination)
            except OSError: pass

    @staticmethod
    def symlinks_on_windows(source, destination, safe):
        &#34;&#34;&#34;Yes, source and destination need to be in the reverse order.&#34;&#34;&#34;
        import win32file
        if os.path.isdir(source):
            return win32file.CreateSymbolicLink(destination, source, 1)
        else:
            return win32file.CreateSymbolicLink(destination, source, 0)

    #------------------------------ Hard links -------------------------------#
    def hard_link_win_to(self, path):
        &#34;&#34;&#34;
        In the case of Windows
        &#34;&#34;&#34;
        # Get source and destination #
        from autopaths import Path
        source      = self
        destination = Path(path)
        # Call method #
        os.link(source, destination)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="autopaths.base_path.BasePath"><code class="flex name class">
<span>class <span class="ident">BasePath</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>This object contains methods that are common to both FilePath objects
and DirectoryPath objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePath(str):
    &#34;&#34;&#34;
    This object contains methods that are common to both FilePath objects
    and DirectoryPath objects.
    &#34;&#34;&#34;

    def __repr__(self):
        return &#39;&lt;%s object &#34;%s&#34;&gt;&#39; % (self.__class__.__name__, self.path)

    @classmethod
    def clean_path(cls, path):
        &#34;&#34;&#34;Given a path, return a cleaned up version for initialization.&#34;&#34;&#34;
        # Conserve &#39;None&#39; object style #
        if path is None: return None
        # Don&#39;t nest BasePaths object or the like #
        if hasattr(path, &#39;path&#39;): path = path.path
        # Expand the tilda #
        if &#34;~&#34; in path: path = os.path.expanduser(path)
        # We will store the path with the OS specific separator #
        # We will never mix both kinds of separators #
        if os.name == &#34;posix&#34;: path = path.replace(&#34;\\&#34;, sep)
        if os.name == &#34;nt&#34;:    path = path.replace(&#34;/&#34;,  sep)
        # Expand star #
        if &#34;*&#34; in path:
            matches = glob.glob(path)
            if len(matches) &lt; 1:
                raise Exception(&#34;Found exactly no paths matching &#39;%s&#39;&#34; % path)
            if len(matches) &gt; 1:
                raise Exception(&#34;Found several paths matching &#39;%s&#39;&#34; % path)
            path = matches[0]
        # Our standard is to end with a slash for directories #
        if cls is autopaths.dir_path.DirectoryPath:
            if not path.endswith(sep):
                path += sep
        # Return the result #
        return path

    def __new__(cls, path, *args, **kwargs):
        &#34;&#34;&#34;A Path object is in fact a string.&#34;&#34;&#34;
        return str.__new__(cls, cls.clean_path(path))

    def __init__(self, path):
        self.path = self.clean_path(path)

    def __add__(self, other):
        if os.name == &#34;posix&#34;: other = other.replace(&#34;\\&#34;, sep)
        if os.name == &#34;nt&#34;:    other = other.replace(&#34;/&#34;,  sep)
        if other.endswith(sep):
            return autopaths.dir_path.DirectoryPath(self.path + other)
        else:
            return autopaths.file_path.FilePath(self.path + other)

    #------------------------------- Properties ------------------------------#
    @property
    def short_prefix(self):
        &#34;&#34;&#34;Just the filename without any extension or periods.&#34;&#34;&#34;
        return self.name.split(&#39;.&#39;)[0]

    @property
    def extension(self):
        &#34;&#34;&#34;The extension with the leading period.&#34;&#34;&#34;
        return os.path.splitext(self.path)[1]

    @property
    def escaped(self):
        &#34;&#34;&#34;
        The path with special characters escaped.
        For instance a backslash becomes a double backslash.
        &#34;&#34;&#34;
        return self.path.replace(&#34;\\&#34;, &#34;\\\\&#34;)

    @property
    def absolute_path(self):
        &#34;&#34;&#34;The absolute path starting with a `/`.&#34;&#34;&#34;
        return self.__class__(os.path.abspath(self.path))

    @property
    def physical_path(self):
        &#34;&#34;&#34;The physical path like in `pwd -P`.&#34;&#34;&#34;
        return self.__class__(os.path.realpath(self.path))

    @property
    def with_tilda(self):
        &#34;&#34;&#34;
        The absolute path starting with a &#39;~&#39; if it&#39;s in the home.
        Returns a string, not an autopaths object, since autopaths can&#39;t
        be encoded with a tilda.
        &#34;&#34;&#34;
        # Get variables #
        home = os.path.expanduser(&#39;~&#39;)
        path = self.absolute_path
        # Check we are in the home #
        if not path.startswith(home): return path
        # Replace #
        return path.replace(home, &#39;~&#39;, 1)

    @property
    def relative_path(self):
        &#34;&#34;&#34;The relative path when compared with current directory.&#34;&#34;&#34;
        return self.__class__(os.path.relpath(self.physical_path))

    def rel_path_from(self, path):
        &#34;&#34;&#34;The relative path when compared to the given path.&#34;&#34;&#34;
        return self.__class__(os.path.relpath(self.path, path))

    @property
    def unix_style(self):
        &#34;&#34;&#34;The path with forward slashes and no disk drive.&#34;&#34;&#34;
        if self.path[1] == &#39;:&#39;: path = self.path[2:]
        else:                   path = self.path
        return path.replace(&#34;\\&#34;, &#34;/&#34;)

    @property
    def wsl_style(self):
        &#34;&#34;&#34;
        The path with forward slashes and a windows subsystem
        for linux style leading disk drive.
        &#34;&#34;&#34;
        return &#34;/mnt/c&#34; + self.unix_style

    @property
    def win_style(self):
        &#34;&#34;&#34;The path with backward slashes.&#34;&#34;&#34;
        return self.path.replace(&#34;/&#34;, &#34;\\&#34;)

    @property
    def exists(self):
        &#34;&#34;&#34;
        Does it exist in the file system?
        Returns True even for broken symbolic links.
        &#34;&#34;&#34;
        return os.path.lexists(self.path)

    @property
    def is_symlink(self):
        &#34;&#34;&#34;Is this file a symbolic link to an other file?&#34;&#34;&#34;
        if os.name == &#34;posix&#34;: return os.path.islink(self.path)
        if os.name == &#34;nt&#34;:
            import win32api
            import win32con
            num = win32con.FILE_ATTRIBUTE_REPARSE_POINT
            return bool(win32api.GetFileAttributes(self.path) &amp; num)

    @property
    def permissions(self):
        &#34;&#34;&#34;Convenience object for dealing with permissions.&#34;&#34;&#34;
        return autopaths.file_permissions.FilePermissions(self.path)

    @property
    def mdate(self):
        &#34;&#34;&#34;Return the modification date as a unix time.&#34;&#34;&#34;
        return os.path.getmtime(self.path)

    @property
    def mdate_iso(self):
        &#34;&#34;&#34;Return the modification date as a datetime iso object.&#34;&#34;&#34;
        import datetime
        return datetime.fromtimestamp(self.mdate).isoformat()

    @property
    def cdate(self):
        &#34;&#34;&#34;Return the creation date.&#34;&#34;&#34;
        return os.path.getctime(self.path)

    @property
    def cdate_iso(self):
        &#34;&#34;&#34;Return the creation date as a datetime iso object.&#34;&#34;&#34;
        import datetime
        return datetime.fromtimestamp(self.cdate).isoformat()

    #------------------------------ Soft links -------------------------------#
    def link_from(self, path, safe=False, absolute=False):
        &#34;&#34;&#34;
        Make a link here pointing to another file/directory somewhere else.
        The destination is hence *self* and the source is *path*.
        &#34;&#34;&#34;
        # Get source and destination #
        from autopaths import Path
        source      = Path(path)
        destination = self
        # Call method #
        self._symlink(source, destination, safe, absolute)

    def link_to(self, path, safe=False, absolute=False):
        &#34;&#34;&#34;
        Create a link somewhere else pointing to this file.
        The destination is hence *path* and the source is *self*.
        &#34;&#34;&#34;
        # Get source and destination #
        from autopaths import Path
        source      = self
        destination = Path(path)
        # Call method #
        self._symlink(source, destination, safe, absolute)

    def _symlink(self, source, destination, safe, absolute):
        # If source is a file and the destination is a dir, put it inside #
        if os.path.isdir(destination) and not os.path.isdir(source):
            destination = destination + source.filename
        # Do we want absolute paths #
        if absolute: source = source.absolute_path
        # Strip trailing separators #
        source      = source.rstrip(sep)
        destination = destination.rstrip(sep)
        # Windows doesn&#39;t have os.symlink #
        if os.name == &#34;posix&#34;:
            self.symlinks_on_linux(source, destination, safe)
        if os.name == &#34;nt&#34;:
            self.symlinks_on_windows(source, destination, safe)

    @staticmethod
    def symlinks_on_linux(source, destination, safe):
        # Do it unsafely #
        if not safe:
            if os.path.exists(destination) or os.path.islink(destination):
                os.remove(destination)
            os.symlink(source, destination)
        # Do it safely #
        if safe:
            try: os.remove(destination)
            except OSError: pass
            try: os.symlink(source, destination)
            except OSError: pass

    @staticmethod
    def symlinks_on_windows(source, destination, safe):
        &#34;&#34;&#34;Yes, source and destination need to be in the reverse order.&#34;&#34;&#34;
        import win32file
        if os.path.isdir(source):
            return win32file.CreateSymbolicLink(destination, source, 1)
        else:
            return win32file.CreateSymbolicLink(destination, source, 0)

    #------------------------------ Hard links -------------------------------#
    def hard_link_win_to(self, path):
        &#34;&#34;&#34;
        In the case of Windows
        &#34;&#34;&#34;
        # Get source and destination #
        from autopaths import Path
        source      = self
        destination = Path(path)
        # Call method #
        os.link(source, destination)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="autopaths.dir_path.DirectoryPath" href="dir_path.html#autopaths.dir_path.DirectoryPath">DirectoryPath</a></li>
<li><a title="autopaths.file_path.FilePath" href="file_path.html#autopaths.file_path.FilePath">FilePath</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="autopaths.base_path.BasePath.clean_path"><code class="name flex">
<span>def <span class="ident">clean_path</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a path, return a cleaned up version for initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clean_path(cls, path):
    &#34;&#34;&#34;Given a path, return a cleaned up version for initialization.&#34;&#34;&#34;
    # Conserve &#39;None&#39; object style #
    if path is None: return None
    # Don&#39;t nest BasePaths object or the like #
    if hasattr(path, &#39;path&#39;): path = path.path
    # Expand the tilda #
    if &#34;~&#34; in path: path = os.path.expanduser(path)
    # We will store the path with the OS specific separator #
    # We will never mix both kinds of separators #
    if os.name == &#34;posix&#34;: path = path.replace(&#34;\\&#34;, sep)
    if os.name == &#34;nt&#34;:    path = path.replace(&#34;/&#34;,  sep)
    # Expand star #
    if &#34;*&#34; in path:
        matches = glob.glob(path)
        if len(matches) &lt; 1:
            raise Exception(&#34;Found exactly no paths matching &#39;%s&#39;&#34; % path)
        if len(matches) &gt; 1:
            raise Exception(&#34;Found several paths matching &#39;%s&#39;&#34; % path)
        path = matches[0]
    # Our standard is to end with a slash for directories #
    if cls is autopaths.dir_path.DirectoryPath:
        if not path.endswith(sep):
            path += sep
    # Return the result #
    return path</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.symlinks_on_linux"><code class="name flex">
<span>def <span class="ident">symlinks_on_linux</span></span>(<span>source, destination, safe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def symlinks_on_linux(source, destination, safe):
    # Do it unsafely #
    if not safe:
        if os.path.exists(destination) or os.path.islink(destination):
            os.remove(destination)
        os.symlink(source, destination)
    # Do it safely #
    if safe:
        try: os.remove(destination)
        except OSError: pass
        try: os.symlink(source, destination)
        except OSError: pass</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.symlinks_on_windows"><code class="name flex">
<span>def <span class="ident">symlinks_on_windows</span></span>(<span>source, destination, safe)</span>
</code></dt>
<dd>
<div class="desc"><p>Yes, source and destination need to be in the reverse order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def symlinks_on_windows(source, destination, safe):
    &#34;&#34;&#34;Yes, source and destination need to be in the reverse order.&#34;&#34;&#34;
    import win32file
    if os.path.isdir(source):
        return win32file.CreateSymbolicLink(destination, source, 1)
    else:
        return win32file.CreateSymbolicLink(destination, source, 0)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="autopaths.base_path.BasePath.absolute_path"><code class="name">var <span class="ident">absolute_path</span></code></dt>
<dd>
<div class="desc"><p>The absolute path starting with a <code>/</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def absolute_path(self):
    &#34;&#34;&#34;The absolute path starting with a `/`.&#34;&#34;&#34;
    return self.__class__(os.path.abspath(self.path))</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.cdate"><code class="name">var <span class="ident">cdate</span></code></dt>
<dd>
<div class="desc"><p>Return the creation date.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cdate(self):
    &#34;&#34;&#34;Return the creation date.&#34;&#34;&#34;
    return os.path.getctime(self.path)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.cdate_iso"><code class="name">var <span class="ident">cdate_iso</span></code></dt>
<dd>
<div class="desc"><p>Return the creation date as a datetime iso object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cdate_iso(self):
    &#34;&#34;&#34;Return the creation date as a datetime iso object.&#34;&#34;&#34;
    import datetime
    return datetime.fromtimestamp(self.cdate).isoformat()</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.escaped"><code class="name">var <span class="ident">escaped</span></code></dt>
<dd>
<div class="desc"><p>The path with special characters escaped.
For instance a backslash becomes a double backslash.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def escaped(self):
    &#34;&#34;&#34;
    The path with special characters escaped.
    For instance a backslash becomes a double backslash.
    &#34;&#34;&#34;
    return self.path.replace(&#34;\\&#34;, &#34;\\\\&#34;)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.exists"><code class="name">var <span class="ident">exists</span></code></dt>
<dd>
<div class="desc"><p>Does it exist in the file system?
Returns True even for broken symbolic links.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exists(self):
    &#34;&#34;&#34;
    Does it exist in the file system?
    Returns True even for broken symbolic links.
    &#34;&#34;&#34;
    return os.path.lexists(self.path)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.extension"><code class="name">var <span class="ident">extension</span></code></dt>
<dd>
<div class="desc"><p>The extension with the leading period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extension(self):
    &#34;&#34;&#34;The extension with the leading period.&#34;&#34;&#34;
    return os.path.splitext(self.path)[1]</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.is_symlink"><code class="name">var <span class="ident">is_symlink</span></code></dt>
<dd>
<div class="desc"><p>Is this file a symbolic link to an other file?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_symlink(self):
    &#34;&#34;&#34;Is this file a symbolic link to an other file?&#34;&#34;&#34;
    if os.name == &#34;posix&#34;: return os.path.islink(self.path)
    if os.name == &#34;nt&#34;:
        import win32api
        import win32con
        num = win32con.FILE_ATTRIBUTE_REPARSE_POINT
        return bool(win32api.GetFileAttributes(self.path) &amp; num)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.mdate"><code class="name">var <span class="ident">mdate</span></code></dt>
<dd>
<div class="desc"><p>Return the modification date as a unix time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mdate(self):
    &#34;&#34;&#34;Return the modification date as a unix time.&#34;&#34;&#34;
    return os.path.getmtime(self.path)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.mdate_iso"><code class="name">var <span class="ident">mdate_iso</span></code></dt>
<dd>
<div class="desc"><p>Return the modification date as a datetime iso object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mdate_iso(self):
    &#34;&#34;&#34;Return the modification date as a datetime iso object.&#34;&#34;&#34;
    import datetime
    return datetime.fromtimestamp(self.mdate).isoformat()</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.permissions"><code class="name">var <span class="ident">permissions</span></code></dt>
<dd>
<div class="desc"><p>Convenience object for dealing with permissions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def permissions(self):
    &#34;&#34;&#34;Convenience object for dealing with permissions.&#34;&#34;&#34;
    return autopaths.file_permissions.FilePermissions(self.path)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.physical_path"><code class="name">var <span class="ident">physical_path</span></code></dt>
<dd>
<div class="desc"><p>The physical path like in <code>pwd -P</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def physical_path(self):
    &#34;&#34;&#34;The physical path like in `pwd -P`.&#34;&#34;&#34;
    return self.__class__(os.path.realpath(self.path))</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.relative_path"><code class="name">var <span class="ident">relative_path</span></code></dt>
<dd>
<div class="desc"><p>The relative path when compared with current directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_path(self):
    &#34;&#34;&#34;The relative path when compared with current directory.&#34;&#34;&#34;
    return self.__class__(os.path.relpath(self.physical_path))</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.short_prefix"><code class="name">var <span class="ident">short_prefix</span></code></dt>
<dd>
<div class="desc"><p>Just the filename without any extension or periods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def short_prefix(self):
    &#34;&#34;&#34;Just the filename without any extension or periods.&#34;&#34;&#34;
    return self.name.split(&#39;.&#39;)[0]</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.unix_style"><code class="name">var <span class="ident">unix_style</span></code></dt>
<dd>
<div class="desc"><p>The path with forward slashes and no disk drive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unix_style(self):
    &#34;&#34;&#34;The path with forward slashes and no disk drive.&#34;&#34;&#34;
    if self.path[1] == &#39;:&#39;: path = self.path[2:]
    else:                   path = self.path
    return path.replace(&#34;\\&#34;, &#34;/&#34;)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.win_style"><code class="name">var <span class="ident">win_style</span></code></dt>
<dd>
<div class="desc"><p>The path with backward slashes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def win_style(self):
    &#34;&#34;&#34;The path with backward slashes.&#34;&#34;&#34;
    return self.path.replace(&#34;/&#34;, &#34;\\&#34;)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.with_tilda"><code class="name">var <span class="ident">with_tilda</span></code></dt>
<dd>
<div class="desc"><p>The absolute path starting with a '~' if it's in the home.
Returns a string, not an autopaths object, since autopaths can't
be encoded with a tilda.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def with_tilda(self):
    &#34;&#34;&#34;
    The absolute path starting with a &#39;~&#39; if it&#39;s in the home.
    Returns a string, not an autopaths object, since autopaths can&#39;t
    be encoded with a tilda.
    &#34;&#34;&#34;
    # Get variables #
    home = os.path.expanduser(&#39;~&#39;)
    path = self.absolute_path
    # Check we are in the home #
    if not path.startswith(home): return path
    # Replace #
    return path.replace(home, &#39;~&#39;, 1)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.wsl_style"><code class="name">var <span class="ident">wsl_style</span></code></dt>
<dd>
<div class="desc"><p>The path with forward slashes and a windows subsystem
for linux style leading disk drive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def wsl_style(self):
    &#34;&#34;&#34;
    The path with forward slashes and a windows subsystem
    for linux style leading disk drive.
    &#34;&#34;&#34;
    return &#34;/mnt/c&#34; + self.unix_style</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="autopaths.base_path.BasePath.hard_link_win_to"><code class="name flex">
<span>def <span class="ident">hard_link_win_to</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>In the case of Windows</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hard_link_win_to(self, path):
    &#34;&#34;&#34;
    In the case of Windows
    &#34;&#34;&#34;
    # Get source and destination #
    from autopaths import Path
    source      = self
    destination = Path(path)
    # Call method #
    os.link(source, destination)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.link_from"><code class="name flex">
<span>def <span class="ident">link_from</span></span>(<span>self, path, safe=False, absolute=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a link here pointing to another file/directory somewhere else.
The destination is hence <em>self</em> and the source is <em>path</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_from(self, path, safe=False, absolute=False):
    &#34;&#34;&#34;
    Make a link here pointing to another file/directory somewhere else.
    The destination is hence *self* and the source is *path*.
    &#34;&#34;&#34;
    # Get source and destination #
    from autopaths import Path
    source      = Path(path)
    destination = self
    # Call method #
    self._symlink(source, destination, safe, absolute)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.link_to"><code class="name flex">
<span>def <span class="ident">link_to</span></span>(<span>self, path, safe=False, absolute=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a link somewhere else pointing to this file.
The destination is hence <em>path</em> and the source is <em>self</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link_to(self, path, safe=False, absolute=False):
    &#34;&#34;&#34;
    Create a link somewhere else pointing to this file.
    The destination is hence *path* and the source is *self*.
    &#34;&#34;&#34;
    # Get source and destination #
    from autopaths import Path
    source      = self
    destination = Path(path)
    # Call method #
    self._symlink(source, destination, safe, absolute)</code></pre>
</details>
</dd>
<dt id="autopaths.base_path.BasePath.rel_path_from"><code class="name flex">
<span>def <span class="ident">rel_path_from</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>The relative path when compared to the given path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rel_path_from(self, path):
    &#34;&#34;&#34;The relative path when compared to the given path.&#34;&#34;&#34;
    return self.__class__(os.path.relpath(self.path, path))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="autopaths" href="index.html">autopaths</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="autopaths.base_path.BasePath" href="#autopaths.base_path.BasePath">BasePath</a></code></h4>
<ul class="two-column">
<li><code><a title="autopaths.base_path.BasePath.absolute_path" href="#autopaths.base_path.BasePath.absolute_path">absolute_path</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.cdate" href="#autopaths.base_path.BasePath.cdate">cdate</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.cdate_iso" href="#autopaths.base_path.BasePath.cdate_iso">cdate_iso</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.clean_path" href="#autopaths.base_path.BasePath.clean_path">clean_path</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.escaped" href="#autopaths.base_path.BasePath.escaped">escaped</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.exists" href="#autopaths.base_path.BasePath.exists">exists</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.extension" href="#autopaths.base_path.BasePath.extension">extension</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.hard_link_win_to" href="#autopaths.base_path.BasePath.hard_link_win_to">hard_link_win_to</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.is_symlink" href="#autopaths.base_path.BasePath.is_symlink">is_symlink</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.link_from" href="#autopaths.base_path.BasePath.link_from">link_from</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.link_to" href="#autopaths.base_path.BasePath.link_to">link_to</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.mdate" href="#autopaths.base_path.BasePath.mdate">mdate</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.mdate_iso" href="#autopaths.base_path.BasePath.mdate_iso">mdate_iso</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.permissions" href="#autopaths.base_path.BasePath.permissions">permissions</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.physical_path" href="#autopaths.base_path.BasePath.physical_path">physical_path</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.rel_path_from" href="#autopaths.base_path.BasePath.rel_path_from">rel_path_from</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.relative_path" href="#autopaths.base_path.BasePath.relative_path">relative_path</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.short_prefix" href="#autopaths.base_path.BasePath.short_prefix">short_prefix</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.symlinks_on_linux" href="#autopaths.base_path.BasePath.symlinks_on_linux">symlinks_on_linux</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.symlinks_on_windows" href="#autopaths.base_path.BasePath.symlinks_on_windows">symlinks_on_windows</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.unix_style" href="#autopaths.base_path.BasePath.unix_style">unix_style</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.win_style" href="#autopaths.base_path.BasePath.win_style">win_style</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.with_tilda" href="#autopaths.base_path.BasePath.with_tilda">with_tilda</a></code></li>
<li><code><a title="autopaths.base_path.BasePath.wsl_style" href="#autopaths.base_path.BasePath.wsl_style">wsl_style</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>